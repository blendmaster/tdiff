// Generated by LiveScript 1.2.0
var children, childrenOf, label, postorder, setToArray, visit, ids, Forest, minAndMapping, addDistanceAndMapping, memo, distanceAndMapping, COST, L, genHtml, diag, bindTree, $, $q, $$, input1, error1, raw1, output1, input2, error2, raw2, output2, tree1, tree2, bindForest, calcDiff, parse, parse1, parse2, slice$ = [].slice, out$ = typeof exports != 'undefined' && exports || this;
children = {
  AssignmentExpression: function(it){
    return [it.left, it.right];
  },
  ArrayExpression: function(it){
    return it.elements;
  },
  BlockStatement: function(it){
    return it.body;
  },
  BinaryExpression: function(it){
    return [it.left, it.right];
  },
  BreakStatement: function(it){
    return [it.identitifier];
  },
  CallExpression: function(it){
    return [it.callee].concat(it.arguments);
  },
  CatchClause: function(it){
    return [it.param, it.guard, it.body];
  },
  ConditionalExpression: function(it){
    return [it.test, it.alternate, it.consequent];
  },
  ContinueStatement: function(it){
    return [it.identifier];
  },
  DoWhileStatement: function(it){
    return [it.body, it.test];
  },
  DebuggerStatement: function(){
    return [];
  },
  EmptyStatement: function(){
    return [];
  },
  ExpressionStatement: function(it){
    return [it.expression];
  },
  ForStatement: function(it){
    return [it.init, it.test, it.update, it.body];
  },
  ForInStatement: function(it){
    return [it.left, it.right, it.body];
  },
  FunctionDeclaration: function(it){
    return [it.id].concat(it.params, [it.body]);
  },
  FunctionExpression: function(it){
    return [it.id].concat(it.params, [it.body]);
  },
  Identifier: function(){
    return [];
  },
  IfStatement: function(it){
    return [it.test, it.consequent, it.alternate];
  },
  Literal: function(){
    return [];
  },
  LabeledStatement: function(it){
    return [it.body];
  },
  LogicalExpression: function(it){
    return [it.left, it.right];
  },
  MemberExpression: function(it){
    return [it.object, it.property];
  },
  NewExpression: function(it){
    return [it.callee].concat(it.arguments);
  },
  ObjectExpression: function(it){
    return it.properties;
  },
  Program: function(it){
    return it.body;
  },
  Property: function(it){
    return [it.key, it.value];
  },
  ReturnStatement: function(it){
    return [it.argument];
  },
  SequenceExpression: function(it){
    return it.expressions;
  },
  SwitchStatement: function(it){
    return [it.discriminant].concat(it.cases);
  },
  SwitchCase: function(it){
    return [it.test].concat(it.consequent);
  },
  ThisExpression: function(){
    return [];
  },
  ThrowStatement: function(it){
    return [it.argument];
  },
  TryStatement: function(it){
    return [it.block, it.handler, it.finalizer];
  },
  UnaryExpression: function(it){
    return [it.argument];
  },
  UpdateExpression: function(it){
    return [it.argument];
  },
  VariableDeclaration: function(it){
    return it.declarations;
  },
  VariableDeclarator: function(it){
    return [it.id, it.init];
  },
  WhileStatement: function(it){
    return [it.test, it.body];
  },
  WithStatement: function(it){
    return [it.expression, it.body];
  }
};
childrenOf = function(it){
  return children[it.type](it).filter(function(it){
    return it != null;
  });
};
label = {
  AssignmentExpression: function(){
    return '=';
  },
  ArrayExpression: function(){
    return '[]';
  },
  BlockStatement: function(){
    return '{}';
  },
  BinaryExpression: function(it){
    return it.operator;
  },
  BreakStatement: function(){
    return 'break';
  },
  CallExpression: function(){
    return '()';
  },
  CatchClause: function(){
    return 'catch';
  },
  ConditionalExpression: function(){
    return '?:';
  },
  ContinueStatement: function(){
    return 'continue';
  },
  DoWhileStatement: function(){
    return 'do';
  },
  DebuggerStatement: function(){
    return 'debugger';
  },
  EmptyStatement: function(){
    return ';';
  },
  ExpressionStatement: function(){
    return ';';
  },
  ForStatement: function(){
    return 'for';
  },
  ForInStatement: function(){
    return 'for';
  },
  FunctionDeclaration: function(){
    return 'function';
  },
  FunctionExpression: function(){
    return 'function';
  },
  Identifier: function(it){
    return it.name;
  },
  IfStatement: function(){
    return 'if';
  },
  Literal: function(it){
    return it.raw;
  },
  LabeledStatement: function(){
    return 'label';
  },
  LogicalExpression: function(it){
    return it.operator;
  },
  MemberExpression: function(){
    return '.';
  },
  NewExpression: function(){
    return 'new';
  },
  ObjectExpression: function(){
    return '{}';
  },
  Program: function(){
    return '.js';
  },
  Property: function(){
    return ':';
  },
  ReturnStatement: function(){
    return 'return';
  },
  SequenceExpression: function(){
    return ',';
  },
  SwitchStatement: function(){
    return 'switch';
  },
  SwitchCase: function(it){
    if (it.test != null) {
      return 'case';
    } else {
      return 'default';
    }
  },
  ThisExpression: function(){
    return 'this';
  },
  ThrowStatement: function(){
    return 'throw';
  },
  TryStatement: function(){
    return 'try';
  },
  UnaryExpression: function(it){
    return it.operator;
  },
  UpdateExpression: function(it){
    return it.operator;
  },
  VariableDeclaration: function(){
    return 'var';
  },
  VariableDeclarator: function(){
    return 'var';
  },
  WhileStatement: function(){
    return 'while';
  },
  WithStatement: function(){
    return 'with';
  }
};
postorder = function(root){
  var n, stack, frame, ref$, node, children, child;
  n = 0;
  stack = [[root, childrenOf(root)]];
  while (stack.length > 0) {
    ref$ = frame = stack.pop(), node = ref$[0], children = ref$[1];
    if (children.length > 0) {
      child = children.shift();
      stack.push(frame, [child, childrenOf(child)]);
    } else {
      node.postorder = n++;
    }
  }
};
setToArray = function(it){
  var x$;
  x$ = [];
  it.forEach(function(el){
    x$.push(el);
  });
  return x$;
};
visit = function(root, children, fn){
  var q, node;
  q = [root];
  while ((node = q.pop()) != null) {
    fn(node);
    q.push.apply(q, children[node.postorder]);
  }
};
ids = 0;
Forest = (function(){
  Forest.displayName = 'Forest';
  var prototype = Forest.prototype, constructor = Forest;
  function Forest(nodes, leftmostRoot, children, roots){
    var i$, len$, node, uniqRootIds, uniqRoots, n, ref$, root, sortedRoots, minusLeftmostRoots, child, minusLeftmostUniqRootIds, minusLeftmostUniqRoots, minusLeftmostSortedRoots, minusLeftmost, leftmostSubtreeNodes, leftmostSubtreeRoots, leftmostSubtree, minusLeftmostSubtreeNodes, secondLeftmostRoot, minusLeftmostSubtreeRoots, this$ = this;
    this.nodes = nodes;
    this.leftmostRoot = leftmostRoot;
    this.children = children;
    this.roots = roots;
    this.id = ids++;
    this.size = this.nodes.length;
    if (this.size === 0) {
      return;
    }
    for (i$ = 0, len$ = nodes.length; i$ < len$; ++i$) {
      node = nodes[i$];
      if (this.roots[node.postorder] == null) {
        throw new Error('fuck');
      }
    }
    this.isTree = true;
    uniqRootIds = {};
    uniqRoots = [];
    for (n in ref$ = this.roots) {
      root = ref$[n];
      if (uniqRootIds[root.postorder] == null) {
        uniqRoots.push(root);
      }
      uniqRootIds[root.postorder] = true;
      if (root !== this.leftmostRoot) {
        this.isTree = false;
      }
    }
    sortedRoots = uniqRoots.sort(function(a, b){
      return a.postorder - b.postorder;
    });
    minusLeftmostRoots = {};
    for (i$ = 0, len$ = (ref$ = this.children[this.leftmostRoot.postorder]).length; i$ < len$; ++i$) {
      child = ref$[i$];
      visit(child, this.children, fn$);
    }
    for (n in ref$ = this.roots) {
      root = ref$[n];
      if (root !== this.leftmostRoot) {
        minusLeftmostRoots[n] = root;
      }
    }
    minusLeftmostUniqRootIds = {};
    minusLeftmostUniqRoots = [];
    for (n in minusLeftmostRoots) {
      root = minusLeftmostRoots[n];
      if (minusLeftmostUniqRootIds[root.postorder] == null) {
        minusLeftmostUniqRoots.push(root);
      }
      minusLeftmostUniqRootIds[root.postorder] = true;
    }
    minusLeftmostSortedRoots = minusLeftmostUniqRoots.sort(function(a, b){
      return a.postorder - b.postorder;
    });
    minusLeftmost = this.nodes.filter(function(it){
      return it !== this$.leftmostRoot;
    });
    this.minusLeftmost = new Forest(minusLeftmost, minusLeftmostSortedRoots[0], this.children, minusLeftmostRoots);
    leftmostSubtreeNodes = this.nodes.filter(function(it){
      return this$.roots[it.postorder] === this$.leftmostRoot;
    });
    leftmostSubtreeRoots = {};
    for (i$ = 0, len$ = leftmostSubtreeNodes.length; i$ < len$; ++i$) {
      node = leftmostSubtreeNodes[i$];
      leftmostSubtreeRoots[node.postorder] = this.leftmostRoot;
    }
    leftmostSubtree = this.nodes.filter(function(it){
      return this$.roots[it.postorder] === this$.leftmostRoot;
    });
    this.leftmostSubtree = leftmostSubtree.length === this.nodes.length
      ? this
      : new Forest(leftmostSubtree, this.leftmostRoot, this.children, leftmostSubtreeRoots);
    minusLeftmostSubtreeNodes = this.nodes.filter(function(it){
      return this$.roots[it.postorder] !== this$.leftmostRoot;
    });
    secondLeftmostRoot = sortedRoots[1];
    minusLeftmostSubtreeRoots = {};
    for (i$ = 0, len$ = minusLeftmostSubtreeNodes.length; i$ < len$; ++i$) {
      node = minusLeftmostSubtreeNodes[i$];
      minusLeftmostSubtreeRoots[node.postorder] = this.roots[node.postorder];
    }
    this.minusLeftmostSubtree = new Forest(minusLeftmostSubtreeNodes, secondLeftmostRoot, this.children, minusLeftmostSubtreeRoots);
    function fn$(it){
      minusLeftmostRoots[it.postorder] = child;
    }
  }
  constructor.fromAst = function(ast){
    var nodes, leftmostRoot, children, roots, q, node, n, c;
    nodes = [];
    leftmostRoot = ast;
    children = {};
    roots = {};
    q = [ast];
    while ((node = q.pop()) != null) {
      n = node.postorder;
      c = childrenOf(node);
      nodes.push(node);
      children[n] = c;
      roots[n] = leftmostRoot;
      q.push.apply(q, c);
    }
    return new Forest(nodes, leftmostRoot, children, roots);
  };
  return Forest;
}());
minAndMapping = function(){
  var choices, minDist, min, i$, len$, choice, distance;
  choices = slice$.call(arguments);
  minDist = Infinity;
  min = void 8;
  for (i$ = 0, len$ = choices.length; i$ < len$; ++i$) {
    choice = choices[i$], distance = choice[0];
    if (distance < minDist) {
      min = choice;
    }
  }
  return min;
};
addDistanceAndMapping = function(arg$, arg1$){
  var addCost, addMapping, distance, mapping;
  addCost = arg$[0], addMapping = arg$[1];
  distance = arg1$[0], mapping = arg1$[1];
  return [distance + addCost, import$(mapping, addMapping)];
};
memo = {};
distanceAndMapping = (function(){
  var fn;
  fn = function(forest1, forest2, cost, mapping){
    var ret, ref$;
    ret = forest1.size === 0 && forest2.size === 0
      ? [0, {}]
      : forest2.size === 0
        ? [forest1.size * cost.deletion, {}]
        : forest1.size === 0
          ? [forest2.size * cost.insertion, {}]
          : forest1.isTree && forest2.isTree
            ? minAndMapping(addDistanceAndMapping([cost.deletion, {}], distanceAndMapping(forest1.minusLeftmost, forest2, cost)), addDistanceAndMapping([cost.insertion, {}], distanceAndMapping(forest1, forest2.minusLeftmost, cost)), addDistanceAndMapping([cost.rename(forest1.leftmostRoot, forest2.leftmostRoot), (ref$ = {}, ref$[forest1.leftmostRoot.postorder] = forest2.leftmostRoot.postorder, ref$)], distanceAndMapping(forest1.minusLeftmost, forest2.minusLeftmost, cost)))
            : minAndMapping(addDistanceAndMapping([cost.deletion, {}], distanceAndMapping(forest1.minusLeftmost, forest2, cost)), addDistanceAndMapping([cost.insertion, {}], distanceAndMapping(forest1, forest2.minusLeftmost, cost)), addDistanceAndMapping(distanceAndMapping(forest1.leftmostSubtree, forest2.leftmostSubtree, cost), distanceAndMapping(forest1.minusLeftmostSubtree, forest2.minusLeftmostSubtree, cost)));
    return ret;
  };
  return function(forest1, forest2, cost, mapping){
    var key$, ref$;
    return (ref$ = memo[key$ = forest1.id + "" + forest2.id]) != null
      ? ref$
      : memo[key$] = fn(forest1, forest2, cost, mapping);
  };
}.call(this));
out$.COST = COST = {
  insertion: 1,
  deletion: 1,
  rename: function(left, right){
    if (left.type === right.type) {
      if (left.type === 'Literal') {
        if (left.raw === right.raw) {
          return 0;
        } else {
          return Infinity;
        }
      } else if (left.type === 'Identifier') {
        if (left.name === right.name) {
          return 0;
        } else {
          return Infinity;
        }
      } else {
        return 0;
      }
    } else {
      return Infinity;
    }
  }
};
L = bind$(document, 'createElement');
genHtml = function(source, ast){
  var starts, ends, q, node, ref$, start, end, key$, el, frag, text, depth, i$, len$, i, c, that, j$, len1$, elem, x$;
  starts = {};
  ends = {};
  q = [ast];
  while ((node = q.pop()) != null) {
    ref$ = node.range, start = ref$[0], end = ref$[1];
    (starts[start] || (starts[start] = [])).push(node);
    (ends[key$ = end - 1] || (ends[key$] = [])).unshift(node);
    q.push.apply(q, childrenOf(node));
  }
  el = frag = document.createDocumentFragment();
  text = '';
  depth = 0;
  for (i$ = 0, len$ = source.length; i$ < len$; ++i$) {
    i = i$;
    c = source[i$];
    if ((that = starts[i]) != null) {
      el.appendChild(document.createTextNode(text));
      text = '';
      for (j$ = 0, len1$ = that.length; j$ < len1$; ++j$) {
        node = that[j$];
        elem = (x$ = L('span'), x$.className = "syntax " + node.type + " ", x$.dataset.postorder = node.postorder, x$);
        depth++;
        el.appendChild(elem);
        el = elem;
      }
    }
    text += c;
    if ((that = ends[i]) != null) {
      el.appendChild(document.createTextNode(text));
      text = '';
      for (j$ = 0, len1$ = that.length; j$ < len1$; ++j$) {
        node = that[j$];
        el = el.parentNode;
        depth--;
      }
    }
  }
  return frag;
};
diag = d3.svg.diagonal().projection(function(it){
  return [it.y, it.x];
});
bindTree = function(ast, code, svg){
  var t, nodes, x$, y$, z$, z1$;
  t = d3.layout.tree().children(childrenOf).size([560, 360]);
  nodes = t.nodes(ast);
  x$ = d3.select(svg);
  y$ = x$.select('.nodes').selectAll('.node').data(nodes);
  y$.exit().remove();
  z$ = y$.enter().append('g').attr({
    'class': 'node'
  });
  z$.append('circle').attr({
    'class': 'node-circle',
    r: 20
  });
  z$.append('text').attr({
    'class': 'node-text'
  });
  y$.attr({
    transform: function(it){
      return "translate(" + it.y + ", " + it.x + ")";
    },
    'data-postorder': function(it){
      return it.postorder;
    },
    title: function(it){
      var ref$, start, end;
      ref$ = it.range, start = ref$[0], end = ref$[1];
      return "" + it.type + "\n\n" + code.substring(start, end);
    }
  });
  y$.select('.node-text').text(function(it){
    return label[it.type](it);
  });
  z1$ = x$.select('.links').selectAll('.link').data(t.links(nodes));
  z1$.exit().remove();
  z1$.enter().append('path').attr('class', 'link');
  z1$.attr('d', diag);
  return x$;
};
$ = bind$(document, 'getElementById');
$q = bind$(document, 'querySelector');
$$ = bind$(document, 'querySelectorAll');
input1 = $('input1');
error1 = $('error1');
raw1 = $('raw1');
output1 = $('output1');
input2 = $('input2');
error2 = $('error2');
raw2 = $('raw2');
output2 = $('output2');
tree1 = $('tree1');
tree2 = $('tree2');
bindForest = function(){
  var ast1, ast2, e, f1, f2;
  try {
    ast1 = esprima.parse(input1.value);
    ast2 = esprima.parse(input2.value);
  } catch (e$) {
    e = e$;
    return;
  }
  postorder(ast1);
  postorder(ast2);
  memo = {};
  console.time('ast1');
  f1 = Forest.fromAst(ast1);
  console.timeEnd('ast1');
  console.time('ast2');
  f2 = Forest.fromAst(ast2);
};
calcDiff = function(){
  var ast1, ast2, e, f1, f2, ref$, distance, mapping, bimap, p1, p2, i$, len$, node, that;
  try {
    ast1 = esprima.parse(input1.value);
    ast2 = esprima.parse(input2.value);
  } catch (e$) {
    e = e$;
    return;
  }
  postorder(ast1);
  postorder(ast2);
  memo = {};
  console.time('ast1');
  f1 = Forest.fromAst(ast1);
  console.timeEnd('ast1');
  console.time('ast2');
  f2 = Forest.fromAst(ast2);
  console.timeEnd('ast2');
  console.time('dist');
  ref$ = distanceAndMapping(f1, f2, COST, {}), distance = ref$[0], mapping = ref$[1];
  console.timeEnd('dist');
  console.log(mapping, distance);
  bimap = {};
  for (p1 in mapping) {
    p2 = mapping[p1];
    bimap[p2] = p1;
  }
  for (i$ = 0, len$ = (ref$ = $$('#tree1 .node')).length; i$ < len$; ++i$) {
    node = ref$[i$];
    if ((that = mapping[node.getAttribute('data-postorder')]) != null) {
      (fn$.call(this, that, node));
    } else {
      node.classList.add('deleted');
    }
  }
  for (i$ = 0, len$ = (ref$ = $$('#tree2 .node')).length; i$ < len$; ++i$) {
    node = ref$[i$];
    if ((that = bimap[node.getAttribute('data-postorder')]) != null) {
      (fn1$.call(this, that, node));
    } else {
      node.classList.add('added');
    }
  }
  for (i$ = 0, len$ = (ref$ = $$('#output1 .syntax')).length; i$ < len$; ++i$) {
    node = ref$[i$];
    if (mapping[node.getAttribute('data-postorder')] != null) {
      node.classList.add('mapped');
    } else {
      node.classList.add('deleted');
    }
  }
  for (i$ = 0, len$ = (ref$ = $$('#output2 .syntax')).length; i$ < len$; ++i$) {
    node = ref$[i$];
    if (bimap[node.getAttribute('data-postorder')] != null) {
      node.classList.add('mapped');
    } else {
      node.classList.add('added');
    }
  }
  function fn$(p2, node){
    var x$;
    x$ = node;
    x$.addEventListener('mouseenter', function(){
      $q("#tree2 .node[data-postorder=\"" + p2 + "\"]").classList.add('mapped');
    });
    x$.addEventListener('mouseleave', function(){
      $q("#tree2 .node[data-postorder=\"" + p2 + "\"]").classList.remove('mapped');
    });
  }
  function fn1$(p1, node){
    var x$;
    x$ = node;
    x$.addEventListener('mouseenter', function(){
      $q("#tree1 .node[data-postorder=\"" + p1 + "\"]").classList.add('mapped');
    });
    x$.addEventListener('mouseleave', function(){
      $q("#tree1 .node[data-postorder=\"" + p1 + "\"]").classList.remove('mapped');
    });
  }
};
parse = function(input, error, raw, output, tree){
  return function(){
    var ast, e, that, normalizedCode, normalizedAst;
    try {
      ast = esprima.parse(input.value, {
        range: true
      });
    } catch (e$) {
      e = e$;
      error.textContent = e;
      input.classList.add('error');
      return;
    }
    postorder(ast);
    raw.textContent = JSON.stringify(ast, void 8, 2);
    bindTree(ast, input.value, tree);
    while ((that = output.firstChild) != null) {
      output.removeChild(that);
    }
    normalizedCode = escodegen.generate(ast);
    normalizedAst = esprima.parse(normalizedCode, {
      range: true
    });
    postorder(normalizedAst);
    output.appendChild(genHtml(normalizedCode, normalizedAst));
    input.classList.remove('error');
    error.textContent = '';
  };
};
parse1 = parse(input1, error1, raw1, output1, tree1);
parse2 = parse(input2, error2, raw2, output2, tree2);
$('input1').addEventListener('input', parse1);
$('input2').addEventListener('input', parse2);
parse1();
parse2();
$('calc').addEventListener('click', calcDiff);
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
function bind$(obj, key, target){
  return function(){ return (target || obj)[key].apply(obj, arguments) };
}